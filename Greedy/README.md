# 그리디 알고리즘(Greedy Algorithm)
> **그리디 알고리즘?🤑**
>
> 매 순간 **가장 좋아 보이는 것을 선택**하여 최종 답에 도달하는 문제 해결 방식이다. 욕심쟁이 방법, 탐욕적 방법, 탐욕 알고리즘 등으로 불리기도 한다. 
>
> 데이터 간의 관계를 고려하지 않고 수행 과정에서 최소값 또는  최댓값을 가진 데이터를 선택한다. 현재의 선택이 다음 선택에 어떠한 영향을 미치는지는 고려하지 않는다. 따라서, 항상 최적의 결과를 보장하는 방법은 아니며 빠르게 정답에 도달해야 하는 상황에 적합하다. 

## 그리디 알고리즘 수행 과정
부분적으로 최적해를 찾고, 이들을 모아서 문제의 최적해를 얻는다.

## 정당성 분석
- <u>최적 부분 구조(Optimal Substructure)</u>
부분 문제에서 항상 최적의 선택을 해서 전체 결과까지 최적해를 얻을 수 있어야 한다.
  
- <u>탐욕적 선택 속성(Greedy Choice Property)</u>
  가장 좋은 것만을 선택해서 최적해를 구할 수 있어야 한다. 
  
  `즉, 한번의 선택이 다음 선택과는 무관하며 부분 문제에서의 최적해가 문제에 대한 최적해가 되어야 한다.`

### 동전 거스름돈💲
여러 종류의 동전을 충분히 가지고 있는 상황에서 거스름돈을 최소 개수의 동전을 구하는 문제

동전 거스름돈(Coin Change) 문제를 해결하는 가장 간단하고 효율적인 방법은 가장 큰 단위의 동전부터 차례대로 확인하여 거슬러 주는 것.

### 최소 신장 트리
> **최소 신장 트리(Minimum Spanning Tree)란?** 주어진 가중치 그래프에서 사이클이 없이 모든 점들을 연결시킨 트리들 중 선분들의 가중치 합이 최소인 트리

주어진 그래프의 신장 트리를 찾으려면 사이클이 없도록 모든 점을 연결시키면 된다. 그래프의 점의 수가 n이면 신장 트리에는 정확히 (n - 1)개의 선분이 있다. 트리에 선분을 하나 추가시키면, 반드시 사이클이 만들어진다.

#### Kruskal의 MST 알고리즘
사이클을 만들지 않을 때만 각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택한다.
먼저 간선들을 가중치의 오름차순으로 정렬한다. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택하여 현재의 최소 비용 신장 트리의 집합에 추가한다. 단, 사이클을 형성하면 그 간선은 제외된다.



1. 모든 간선들을 가중치의 오름차순으로 정렬한다.
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하는지 확인한다.
   1. 사이클이 발생하지 않으면 최소 신장 트리 집합에 추가
   2. 사이클이 발생하면 그 간선은 제외한다.
3. 모든 간선에 대하여 2번의 과정을 반복한다.

```
KruskalMST(G)
입력 : 가중치 그래프 G = (V, E), |V| = n ,|E| = m
출력 : 최소 신장 트리 T

1. 가중치의 오름차순으로 선분 정렬 . (L: 정렬된 선분 리스트 )
2. T = ∅
3. while (T의 선분 수 < n – 1) {
4. 	e = L에서 가장 작은 가중치를 가진 선분 , e를 L에서 제거
5. 	if (선분 e가 T에 추가되어 사이클을 만들지 않으면)
6. 		e 를 T에 추가시킨다.
7. 	else
8. 		e를 버린다.
	}
9. return 트리 T
```

**논의**

<u>추가된 선분이 사이클을 만드는지?</u> 

👉 추가하려는 선분의 두 노드가 같은 그룹에 있으면 사이클을 생성

<u>같은 그룹은 어떻게 판별?</u>

👉 각 그룹마다 대표(parent)를 선정한다



**시간복잡도**

O(m log m),  m: 간선의 개수

간선을 정렬하는 작업이 가장 오래 걸린다. m개의 데이터를 정렬했을 때 O(n log n).



#### Prim의 MST 알고리즘

주어진 가중치 그래프에서 임의의 점 하나를 선택한 후, 인접한 선분을 하나씩 추가시켜 (n - 1)개의 선분으로 이루어진 트리를 만든다. 추가되는 선분은 현재까지 만들어진 트리에 연결시킬 때 항상 최소의 가중치로 연결되는 선분이다.



1. 그래프에서 임의의 점 하나를 선택한다.
2. 선택한 점과 인접하는 점들 중 최소 비용이 되는 간선을 선택한다.
   1. 가장 비용이 작은 간선을 트리에 추가한다.
   2. 트리에 속한 점이면 선택하지 않는다.
3. 모든 점이 선택될 때까지 2번의 과정을 반복한다.

```
PrimMST(G)

입력: 가중치 그래프 G=(V, E), |V| = n, |E| = m
출력: MST T
	
1. 그래프 G에서 임의의 점 p를 시작점으로 선택하고 D[p]=0 으로 초기화
	(D[v]는 T에 있는 점 u와 v를 연결하는 선분의 최소 가중치를 저장)
2. for (점 p가 아닌 각 점 v에 대하여) {
3.	if (선분 (p, v)가 그래프에 있으면)
4.		D[v] = 선분 (p, v)의 가중치
5.	else
6.		D[v] = ∞
	}
7. T = {p}
8. while (T에 있는 점의 수 < n) {
9.	점 vmin가 D[]에서 최소인 값을 가지면, 선분(u, vmin)을 T에 추가한다. 점 u ∈ T
10. for (T에 속하지 않은 각 점 w에 대해서) {
11.  if (선분(vmin, w)의 가중치 < D[w])
12.		D[w] = 선분(vmin, w)의 가중치
	 }
	}
13. return T
```

**논의**

<u>PrimMST 알고리즘이 최종적으로 리턴하는 T에는 왜 사이클이 없을까?</u>

👉 항상 T 밖에 있는 점을 추가하므로 사이클이 형성되지 않는다.



## Reference

📗 [백준 그리디 알고리즘](https://www.acmicpc.net/problemset?sort=ac_desc&algo=33)

📗 [동전 거스름돈 알고리즘](https://jackpot53.tistory.com/106)

📗 [최소 비용 신장트리(MST) 알고리즘](https://hibee.tistory.com/300)
